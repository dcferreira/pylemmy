{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pylemmy","text":"<p>pylemmy enables simple access to Lemmy's API with Python.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pylemmy\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Simple example of running a Python function on new posts, as they are created.</p> <pre><code>from pylemmy import Lemmy\n\ndef process_post(post):\n    ...\n\nlemmy = Lemmy(\n    lemmy_url=\"http://127.0.0.1:8536\",\n    username=\"lemmy\",\n    password=\"lemmylemmy\",\n    user_agent=\"custom user agent (by u/USERNAME)\",\n)\n\ncommunity = lemmy.get_community(\"test\")\nfor post in community.stream.get_posts():\n    process_post(post)\n</code></pre> <p>Stream over comments in multiple communities, and print their content.</p> <pre><code>from pylemmy import Lemmy\n\ndef process_comment(comment):\n    print(comment)\n\nlemmy = Lemmy(\n    lemmy_url=\"http://127.0.0.1:8536\",\n    username=\"lemmy\",\n    password=\"lemmylemmy\",\n    user_agent=\"custom user agent (by u/USERNAME)\",\n)\n\nmulti_communities = lemmy.multi_communities_stream([\"community1\", \"community2\"])\nmulti_communities.comments_apply(process_comment)\n</code></pre> <p>For more examples, see the examples directory on GitHub.</p>"},{"location":"api/lemmy/","title":"Lemmy","text":"<p>Implements the Lemmy class.</p>"},{"location":"api/lemmy/#pylemmy.lemmy.Lemmy","title":"<code>Lemmy(lemmy_url, username, password, user_agent, request_timeout=30)</code>","text":"<p>The Lemmy class provides the main entrypoint for pylemmy, and Lemmy's API.</p> <p>This class manages all the settings relating how to access your chosen Lemmy instance, and implements the Lemmy API.</p> <p>Example:</p> <pre><code>from pylemmy import Lemmy\n\nlemmy = Lemmy(\n    lemmy_url=\"http://127.0.0.1:8536\",\n    username=\"lemmy\",\n    password=\"lemmylemmy\",\n    user_agent=\"custom user-agent (by u/USERNAME)\",\n)\n</code></pre> <p>Initialize a Lemmy instance.</p> <p>Parameters:</p> <ul> <li> <code>lemmy_url</code>             (<code>Union[str, AnyUrl]</code>)         \u2013          <p>The URL for the Lemmy instance you want to access.</p> </li> <li> <code>username</code>             (<code>Optional[str]</code>)         \u2013          <p>Your Lemmy username or email.</p> </li> <li> <code>password</code>             (<code>Optional[str]</code>)         \u2013          <p>Your Lemmy password</p> </li> <li> <code>user_agent</code>             (<code>str</code>)         \u2013          <p>The user agent the requests will use.</p> </li> <li> <code>request_timeout</code>             (<code>int</code>, default:                 <code>30</code> )         \u2013          <p>A maximum timeout to wait for requests (in seconds).</p> </li> </ul> Source code in <code>pylemmy/lemmy.py</code> <pre><code>def __init__(\n    self,\n    lemmy_url: Union[str, AnyUrl],\n    username: Optional[str],\n    password: Optional[str],\n    user_agent: str,\n    request_timeout: int = 30,\n):\n\"\"\"Initialize a Lemmy instance.\n\n    :param lemmy_url: The URL for the Lemmy instance you want to access.\n    :param username: Your Lemmy username or email.\n    :param password: Your Lemmy password\n    :param user_agent: The user agent the requests will use.\n    :param request_timeout: A maximum timeout to wait for requests (in seconds).\n    \"\"\"\n    self.lemmy_url = (\n        lemmy_url\n        if isinstance(lemmy_url, AnyUrl)\n        else TypeAdapter(AnyUrl).validate_python(lemmy_url)\n    )\n    self.username = username\n    self.password = password\n    self.user_agent = user_agent\n\n    self.request_timeout = request_timeout\n\n    self._login_response: Optional[api.auth.LoginResponse] = None\n\n    self.session = requests.Session()\n    self.session.headers.update({\"User-Agent\": self.user_agent})\n</code></pre>"},{"location":"api/lemmy/#pylemmy.lemmy.Lemmy.create_community","title":"<code>create_community(name, title, **kwargs)</code>","text":"<p>Create a community with the given name and title.</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Name of the community (stub-like, this will be in the URL).</p> </li> <li> <code>title</code>             (<code>str</code>)         \u2013          <p>Title of the community, in natural language.</p> </li> <li> <code>kwargs</code>         \u2013          <p>See optional arguments in CreateCommunity.</p> </li> </ul> Source code in <code>pylemmy/lemmy.py</code> <pre><code>def create_community(self, name: str, title: str, **kwargs) -&gt; Community:\n\"\"\"Create a community with the given name and title.\n\n    :param name: Name of the community (stub-like, this will be in the URL).\n    :param title: Title of the community, in natural language.\n    :param kwargs: See optional arguments in [CreateCommunity](\n    https://join-lemmy.org/api/interfaces/CreateCommunity.html).\n    \"\"\"\n    self.get_token()\n    payload = api.community.CreateCommunity(name=name, title=title, **kwargs)\n    result = self.post_request(LemmyAPI.Community, params=payload)\n    parsed_result = api.community.CommunityResponse(**result)\n\n    return Community(self, parsed_result.community_view)\n</code></pre>"},{"location":"api/lemmy/#pylemmy.lemmy.Lemmy.get_comment","title":"<code>get_comment(comment_id=None)</code>","text":"<p>Get a comment from its id.</p> <p>Parameters:</p> <ul> <li> <code>comment_id</code>             (<code>Optional[int]</code>, default:                 <code>None</code> )         \u2013          <p>Id of the comment.</p> </li> </ul> Source code in <code>pylemmy/lemmy.py</code> <pre><code>def get_comment(self, comment_id: Optional[int] = None) -&gt; Comment:\n\"\"\"Get a comment from its id.\n\n    :param comment_id: Id of the comment.\n    \"\"\"\n    if comment_id is not None:\n        payload = api.comment.GetComment(id=comment_id)\n    else:\n        msg = \"Need to give a comment id.\"\n        raise ValueError(msg)\n\n    result = self.get_request(LemmyAPI.Comment, params=payload)\n    parsed_result = api.comment.CommentResponse(**result)\n\n    return Comment(self, parsed_result.comment_view)\n</code></pre>"},{"location":"api/lemmy/#pylemmy.lemmy.Lemmy.get_community","title":"<code>get_community(community)</code>","text":"<p>Get a community by id or name.</p> <p>Parameters:</p> <ul> <li> <code>community</code>             (<code>Union[str, int]</code>)         \u2013          <p>Either a community id (int) or name (str).</p> </li> </ul> Source code in <code>pylemmy/lemmy.py</code> <pre><code>def get_community(self, community: Union[str, int]) -&gt; Community:\n\"\"\"Get a community by id or name.\n\n    :param community: Either a community id (int) or name (str).\n    \"\"\"\n    if isinstance(community, str):\n        payload = api.community.GetCommunity(name=community)\n    elif isinstance(community, int):\n        payload = api.community.GetCommunity(id=community)\n    else:\n        raise ValueError()\n\n    result = self.get_request(LemmyAPI.Community, params=payload)\n    parsed_result = api.community.GetCommunityResponse(**result)\n    return Community(self, parsed_result.community_view)\n</code></pre>"},{"location":"api/lemmy/#pylemmy.lemmy.Lemmy.get_person_details","title":"<code>get_person_details(person_id=None, username=None)</code>","text":"<p>Get a user from its id or username.</p> <p>Parameters:</p> <ul> <li> <code>person_id</code>         \u2013          <p>Id of the user.</p> </li> <li> <code>username</code>         \u2013          <p>the username of the user</p> </li> </ul> Source code in <code>pylemmy/lemmy.py</code> <pre><code>def get_person_details(self, person_id=None, username=None) -&gt; Person:\n\"\"\"Get a user from its id or username.\n\n    :param person_id: Id of the user.\n    :param username: the username of the user\n    \"\"\"\n    if person_id is not None:\n        payload = api.person.GetPersonDetails(person_id=person_id)\n    elif username is not None:\n        payload = api.person.GetPersonDetails(username=username)\n    else:\n        msg = \"Need to give a person_id or username.\"\n        raise ValueError(msg)\n\n    result = self.get_request(LemmyAPI.Person, params=payload)\n    parsed_result = api.person.GetPersonDetailsResponse(**result)\n\n    return Person(\n        self, parsed_result.person_view.counts, parsed_result.person_view.person\n    )\n</code></pre>"},{"location":"api/lemmy/#pylemmy.lemmy.Lemmy.get_post","title":"<code>get_post(*, post_id=None, comment_id=None)</code>","text":"<p>Get a post from its id.</p> <p>Parameters:</p> <ul> <li> <code>post_id</code>             (<code>Optional[int]</code>, default:                 <code>None</code> )         \u2013          <p>Id of the post.</p> </li> <li> <code>comment_id</code>             (<code>Optional[int]</code>, default:                 <code>None</code> )         \u2013          <p>Id of the comment.</p> </li> </ul> Source code in <code>pylemmy/lemmy.py</code> <pre><code>def get_post(\n    self, *, post_id: Optional[int] = None, comment_id: Optional[int] = None\n) -&gt; Post:\n\"\"\"Get a post from its id.\n\n    :param post_id: Id of the post.\n    :param comment_id: Id of the comment.\n    \"\"\"\n    if post_id is not None:\n        payload = api.post.GetPost(id=post_id)\n    elif comment_id is not None:\n        payload = api.post.GetPost(comment_id=comment_id)\n    else:\n        msg = \"Need to give either a post id or a comment id.\"\n        raise ValueError(msg)\n\n    result = self.get_request(LemmyAPI.Post, params=payload)\n    parsed_result = api.post.GetPostResponse(**result)\n\n    return Post(self, parsed_result.post_view)\n</code></pre>"},{"location":"api/lemmy/#pylemmy.lemmy.Lemmy.get_request","title":"<code>get_request(path, params=None)</code>","text":"<p>Send a GET request to the desired path.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>LemmyAPI</code>)         \u2013          <p>A Lemmy endpoint.</p> </li> <li> <code>params</code>             (<code>Optional[BaseApiModel]</code>, default:                 <code>None</code> )         \u2013          <p>Parameters to send with the request (in the URL).</p> </li> </ul> Source code in <code>pylemmy/lemmy.py</code> <pre><code>def get_request(\n    self,\n    path: LemmyAPI,\n    params: Optional[BaseApiModel] = None,\n):\n\"\"\"Send a GET request to the desired path.\n\n    :param path: A Lemmy endpoint.\n    :param params: Parameters to send with the request (in the URL).\n    \"\"\"\n    token = self.get_token_optional()\n    response = self.session.get(\n        self._get_url(path),\n        params=params.dict() if params is not None else {},\n        headers={\"Authorization\": f\"Bearer {token}\" if token else None},\n        timeout=self.request_timeout,\n    )\n    response.raise_for_status()\n    return response.json()\n</code></pre>"},{"location":"api/lemmy/#pylemmy.lemmy.Lemmy.get_token","title":"<code>get_token()</code>","text":"<p>Get the jwt session token.</p> Source code in <code>pylemmy/lemmy.py</code> <pre><code>def get_token(self) -&gt; str:\n\"\"\"Get the jwt session token.\"\"\"\n    jwt = self.login().jwt\n    if jwt is None:\n        msg = \"No jwt token was found, try logging in again.\"\n        raise RuntimeError(msg)\n    return jwt\n</code></pre>"},{"location":"api/lemmy/#pylemmy.lemmy.Lemmy.get_token_optional","title":"<code>get_token_optional()</code>","text":"<p>Get the jwt session token if it exists, or <code>None</code>.</p> <p>This should be used for requests that don't need authentication.</p> Source code in <code>pylemmy/lemmy.py</code> <pre><code>def get_token_optional(self) -&gt; Optional[str]:\n\"\"\"Get the jwt session token if it exists, or `None`.\n\n    This should be used for requests that don't need authentication.\n    \"\"\"\n    if self.username is None or self.password is None:\n        return None\n    return self.get_token()\n</code></pre>"},{"location":"api/lemmy/#pylemmy.lemmy.Lemmy.list_comment_reports","title":"<code>list_comment_reports(**kwargs)</code>","text":"<p>List comment reports.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>         \u2013          <p>See optional arguments in ListCommentReports.</p> </li> </ul> Source code in <code>pylemmy/lemmy.py</code> <pre><code>def list_comment_reports(self, **kwargs) -&gt; List[api.comment.CommentReportView]:\n\"\"\"List comment reports.\n\n    :param kwargs: See optional arguments in [ListCommentReports](\n    https://join-lemmy.org/api/interfaces/ListCommentReports.html).\n    \"\"\"\n    self.get_token()\n    payload = api.comment.ListCommentReports(**kwargs)\n    result = self.get_request(LemmyAPI.ListPostReports, params=payload)\n    parsed_result = api.comment.ListCommentReportsResponse(**result)\n\n    return parsed_result.comment_reports\n</code></pre>"},{"location":"api/lemmy/#pylemmy.lemmy.Lemmy.list_communities","title":"<code>list_communities(**kwargs)</code>","text":"<p>List the communities in the current Lemmy instance.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>         \u2013          <p>See optional arguments in ListCommunities.</p> </li> </ul> Source code in <code>pylemmy/lemmy.py</code> <pre><code>def list_communities(self, **kwargs) -&gt; List[Community]:\n\"\"\"List the communities in the current Lemmy instance.\n\n    :param kwargs: See optional arguments in [ListCommunities](\n    https://join-lemmy.org/api/interfaces/ListCommunities.html).\n    \"\"\"\n    payload = api.community.ListCommunities(**kwargs)\n    result = self.get_request(LemmyAPI.ListCommunities, params=payload)\n    parsed_result = api.community.ListCommunitiesResponse(**result)\n\n    return [Community(self, view) for view in parsed_result.communities]\n</code></pre>"},{"location":"api/lemmy/#pylemmy.lemmy.Lemmy.list_post_reports","title":"<code>list_post_reports(**kwargs)</code>","text":"<p>List post reports.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>         \u2013          <p>See optional arguments in ListPostReports.</p> </li> </ul> Source code in <code>pylemmy/lemmy.py</code> <pre><code>def list_post_reports(self, **kwargs) -&gt; List[api.post.PostReportView]:\n\"\"\"List post reports.\n\n    :param kwargs: See optional arguments in [ListPostReports](\n    https://join-lemmy.org/api/interfaces/ListPostReports.html).\n    \"\"\"\n    self.get_token()\n    payload = api.post.ListPostReports(**kwargs)\n    result = self.get_request(LemmyAPI.ListPostReports, params=payload)\n    parsed_result = api.post.ListPostReportsResponse(**result)\n\n    return parsed_result.post_reports\n</code></pre>"},{"location":"api/lemmy/#pylemmy.lemmy.Lemmy.login","title":"<code>login()</code>","text":"<p>Login to Lemmy.</p> <p>If the user is already logged in, return the response to the original login request, with the session information.</p> Source code in <code>pylemmy/lemmy.py</code> <pre><code>def login(self) -&gt; api.auth.LoginResponse:\n\"\"\"Login to Lemmy.\n\n    If the user is already logged in, return the response to the original login\n    request, with the session information.\n    \"\"\"\n    if self._login_response is None:\n        if self.username is not None and self.password is not None:\n            response = self.post_request(\n                LemmyAPI.Login,\n                params=api.auth.Login(\n                    username_or_email=self.username, password=self.password\n                ),\n            )\n            parsed_response = api.auth.LoginResponse(**response)\n            if parsed_response.jwt is None:\n                msg = \"Couldn't login! Have you verified your email?\"\n                raise RuntimeError(msg)\n            self._login_response = parsed_response\n        else:\n            msg = \"Need to provide username and password!\"\n            raise ValueError(msg)\n    return self._login_response\n</code></pre>"},{"location":"api/lemmy/#pylemmy.lemmy.Lemmy.multi_communities_stream","title":"<code>multi_communities_stream(communities)</code>","text":"<p>Get streams for multiple communities.</p> <p>Example: A simple example where we want to print the content of each post/comment.</p> <pre><code>def process_content(elem: Union[Post, Comment]):\n    if isinstance(Post, elem):\n        print(elem.post_view.post.name)\n    elif isinstance(Comment, elem):\n        print(elem.comment_view.comment.content\n\nmulti_stream = lemmy.multi_communities_stream([\"community1\", \"community2\"])\nmulti_stream.content_apply(process_content)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>communities</code>             (<code>Iterable[Union[int, str, Community]]</code>)         \u2013          <p>An iterable of community ids, names or instances of Community.</p> </li> </ul> Source code in <code>pylemmy/lemmy.py</code> <pre><code>def multi_communities_stream(\n    self, communities: Iterable[Union[int, str, Community]]\n) -&gt; MultiCommunityStream:\n\"\"\"Get streams for multiple communities.\n\n    Example:\n    A simple example where we want to print the content of each post/comment.\n\n        def process_content(elem: Union[Post, Comment]):\n            if isinstance(Post, elem):\n                print(elem.post_view.post.name)\n            elif isinstance(Comment, elem):\n                print(elem.comment_view.comment.content\n\n        multi_stream = lemmy.multi_communities_stream([\"community1\", \"community2\"])\n        multi_stream.content_apply(process_content)\n\n    :param communities: An iterable of community ids, names or instances of\n    [Community][pylemmy.community.Community].\n    \"\"\"\n    communities_list = (\n        x if isinstance(x, Community) else self.get_community(x)\n        for x in communities\n    )\n    return MultiCommunityStream(list(communities_list))\n</code></pre>"},{"location":"api/lemmy/#pylemmy.lemmy.Lemmy.post_request","title":"<code>post_request(path, params=None)</code>","text":"<p>Send a POST request to the desired path.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>LemmyAPI</code>)         \u2013          <p>A Lemmy endpoint.</p> </li> <li> <code>params</code>             (<code>Optional[BaseApiModel]</code>, default:                 <code>None</code> )         \u2013          <p>Parameters to send with the request (in the body).</p> </li> </ul> Source code in <code>pylemmy/lemmy.py</code> <pre><code>def post_request(\n    self,\n    path: LemmyAPI,\n    params: Optional[BaseApiModel] = None,\n):\n\"\"\"Send a POST request to the desired path.\n\n    :param path: A Lemmy endpoint.\n    :param params: Parameters to send with the request (in the body).\n    \"\"\"\n    token = None if path is LemmyAPI.Login else self.get_token_optional()\n    response = self.session.post(\n        self._get_url(path),\n        json=params.dict() if params is not None else {},\n        headers={\"Authorization\": f\"Bearer {token}\" if token else None},\n        timeout=self.request_timeout,\n    )\n    response.raise_for_status()\n    return response.json()\n</code></pre>"},{"location":"api/lemmy/#pylemmy.lemmy.Lemmy.put_request","title":"<code>put_request(path, params=None)</code>","text":"<p>Send a PUT request to the desired path.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>LemmyAPI</code>)         \u2013          <p>A Lemmy endpoint.</p> </li> <li> <code>params</code>             (<code>Optional[BaseApiModel]</code>, default:                 <code>None</code> )         \u2013          <p>Parameters to send with the request (in the URL).</p> </li> </ul> Source code in <code>pylemmy/lemmy.py</code> <pre><code>def put_request(\n    self,\n    path: LemmyAPI,\n    params: Optional[BaseApiModel] = None,\n):\n\"\"\"Send a PUT request to the desired path.\n\n    :param path: A Lemmy endpoint.\n    :param params: Parameters to send with the request (in the URL).\n    \"\"\"\n    token = self.get_token_optional()\n    response = self.session.put(\n        self._get_url(path),\n        params=params.dict() if params is not None else {},\n        headers={\"Authorization\": f\"Bearer {token}\" if token else None},\n        timeout=self.request_timeout,\n    )\n    return response.json()\n</code></pre>"},{"location":"api/utils/","title":"Utils","text":"<p>General utilities package.</p>"},{"location":"api/utils/#pylemmy.utils.StreamYielder","title":"<code>StreamYielder(*, skip_existing, filter_fn, unique_key_fn, limit, min_wait_time, max_wait_time)</code>","text":"<p>Helper class to manage a stream and keep track of previously seen results.</p> <p>Initialize StreamYielder.</p> <p>Parameters:</p> <ul> <li> <code>unique_key_fn</code>             (<code>Callable[[T], str]</code>)         \u2013          <p>A function that takes an object and outputs a unique id. This is used to keep track of what results were already yielded.</p> </li> <li> <code>filter_fn</code>             (<code>Callable[[T], bool]</code>)         \u2013          <p>Ignore objects which return <code>True</code> for this function.</p> </li> <li> <code>limit</code>             (<code>Optional[int]</code>)         \u2013          <p>Maximum number of objects to yield.</p> </li> <li> <code>max_wait_time</code>             (<code>int</code>)         \u2013          <p>If a function returns no new results, the time between calls to it increases. This sets the maximum time (in seconds) to wait before calling it again.</p> </li> <li> <code>min_wait_time</code>             (<code>int</code>)         \u2013          <p>Minimum time (in seconds) to wait before calling the function again.</p> </li> <li> <code>skip_existing</code>             (<code>bool</code>)         \u2013          <p>If <code>True</code>, skip existing results and return only future ones. In practice, this means the results from the first request are ignored.</p> </li> </ul> Source code in <code>pylemmy/utils.py</code> <pre><code>def __init__(\n    self,\n    *,\n    skip_existing: bool,\n    filter_fn: Callable[[T], bool],\n    unique_key_fn: Callable[[T], str],\n    limit: Optional[int],\n    min_wait_time: int,\n    max_wait_time: int,\n):\n\"\"\"Initialize StreamYielder.\n\n    :param unique_key_fn: A function that takes an object and outputs a unique id.\n    This is used to keep track of what results were already yielded.\n    :param filter_fn: Ignore objects which return `True` for this function.\n    :param limit: Maximum number of objects to yield.\n    :param max_wait_time: If a function returns no new results, the time between\n    calls to it increases. This sets the maximum time (in seconds) to wait before\n    calling it again.\n    :param min_wait_time: Minimum time (in seconds) to wait before calling the\n    function again.\n    :param skip_existing: If `True`, skip existing results and return only future\n    ones.\n    In practice, this means the results from the first request are ignored.\n    \"\"\"\n    self.skip_existing = skip_existing\n    self.filter_fn = filter_fn\n    self.unique_key_fn = unique_key_fn\n    self.limit = limit\n\n    self.results_count = 0\n    self.requests_count = 0\n    self.found_keys: Set[str] = set()\n    self.last_seen_key = \"\"\n\n    self.wait_time = min_wait_time\n    self.min_wait_time = min_wait_time\n    self.max_wait_time = max_wait_time\n</code></pre>"},{"location":"api/utils/#pylemmy.utils.StreamYielder.get_wait_time","title":"<code>get_wait_time(first_key)</code>","text":"<p>Get how long we should wait.</p> <p>Parameters:</p> <ul> <li> <code>first_key</code>             (<code>str</code>)         \u2013          <p>First key seen in the previous iteration. If this is the same as <code>self.last_seen_key</code> it means that no new content was seen in the last request, and so wait time should increase.</p> </li> </ul> Source code in <code>pylemmy/utils.py</code> <pre><code>def get_wait_time(self, first_key: str) -&gt; int:\n\"\"\"Get how long we should wait.\n\n    :param first_key: First key seen in the previous iteration.\n    If this is the same as `self.last_seen_key` it means that no new content\n    was seen in the last request, and so wait time should increase.\n    \"\"\"\n    if first_key == self.last_seen_key:  # no new results\n        self.wait_time = min(2 * self.wait_time, self.max_wait_time)\n    else:\n        self.wait_time = self.min_wait_time\n    return self.wait_time\n</code></pre>"},{"location":"api/utils/#pylemmy.utils.StreamYielder.yield_results","title":"<code>yield_results(results)</code>","text":"<p>Iterate through the results.</p> <p>Parameters:</p> <ul> <li> <code>results</code>             (<code>Iterable[T]</code>)         \u2013          <p>Results from one to the generator function.</p> </li> </ul> Source code in <code>pylemmy/utils.py</code> <pre><code>def yield_results(self, results: Iterable[T]) -&gt; Generator[Optional[T], None, None]:\n\"\"\"Iterate through the results.\n\n    :param results: Results from one to the generator function.\n    \"\"\"\n    skipping_yield = False\n    if self.requests_count == 1 and self.skip_existing:\n        skipping_yield = True\n    for r in filter(self.filter_fn, results):  # type: ignore[var-annotated, arg-type]\n        unique_key = self.unique_key_fn(r)\n        if unique_key not in self.found_keys:\n            self.last_seen_key = unique_key\n            if not skipping_yield:\n                yield r\n                self.results_count += 1\n            if self.limit is not None and self.results_count &gt;= self.limit:\n                yield None\n            self.found_keys.add(unique_key)\n</code></pre>"},{"location":"api/utils/#pylemmy.utils.async_stream_generator","title":"<code>async_stream_generator(results_fn, unique_key_fn, *, filter_fn=lambda _: True, limit=None, max_wait_time=300, min_wait_time=1, skip_existing=False, **function_kwargs)</code>  <code>async</code>","text":"<p>Helper function to generate streams.</p> <p>Parameters:</p> <ul> <li> <code>results_fn</code>             (<code>Callable[[KwArg(Any)], Iterable[T]]</code>)         \u2013          <p>A function to call repeatedly, which outputs a list of objects.</p> </li> <li> <code>unique_key_fn</code>             (<code>Callable[[T], str]</code>)         \u2013          <p>A function that takes an object and outputs a unique id. This is used to keep track of what results were already yielded.</p> </li> <li> <code>filter_fn</code>             (<code>Callable[[T], bool]</code>, default:                 <code>lambda _: True</code> )         \u2013          <p>Ignore objects which return <code>True</code> for this function.</p> </li> <li> <code>limit</code>             (<code>Optional[int]</code>, default:                 <code>None</code> )         \u2013          <p>Maximum number of objects to yield.</p> </li> <li> <code>max_wait_time</code>             (<code>int</code>, default:                 <code>300</code> )         \u2013          <p>If a function returns no new results, the time between calls to it increases. This sets the maximum time (in seconds) to wait before calling it again.</p> </li> <li> <code>min_wait_time</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Minimum time (in seconds) to wait before calling the function again.</p> </li> <li> <code>skip_existing</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, skip existing results and return only future ones. In practice, this means the results from the first request are ignored.</p> </li> <li> <code>function_kwargs</code>             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Keyword parameters that are passed to the function.</p> </li> </ul> Source code in <code>pylemmy/utils.py</code> <pre><code>async def async_stream_generator(\n    results_fn: Callable[[KwArg(Any)], Iterable[T]],\n    unique_key_fn: Callable[[T], str],\n    *,\n    filter_fn: Callable[[T], bool] = lambda _: True,\n    limit: Optional[int] = None,\n    max_wait_time: int = 300,\n    min_wait_time: int = 1,\n    skip_existing: bool = False,\n    **function_kwargs: Any,\n) -&gt; AsyncGenerator[T, None]:\n\"\"\"Helper function to generate streams.\n\n    :param results_fn: A function to call repeatedly, which outputs a list of objects.\n    :param unique_key_fn: A function that takes an object and outputs a unique id.\n    This is used to keep track of what results were already yielded.\n    :param filter_fn: Ignore objects which return `True` for this function.\n    :param limit: Maximum number of objects to yield.\n    :param max_wait_time: If a function returns no new results, the time between calls\n    to it increases. This sets the maximum time (in seconds) to wait before calling it\n    again.\n    :param min_wait_time: Minimum time (in seconds) to wait before calling the function\n    again.\n    :param skip_existing: If `True`, skip existing results and return only future ones.\n    In practice, this means the results from the first request are ignored.\n    :param function_kwargs: Keyword parameters that are passed to the function.\n    \"\"\"\n    stream_obj = StreamYielder(\n        skip_existing=skip_existing,\n        filter_fn=filter_fn,\n        unique_key_fn=unique_key_fn,\n        limit=limit,\n        min_wait_time=min_wait_time,\n        max_wait_time=max_wait_time,\n    )\n    while True:\n        first_key = stream_obj.last_seen_key\n        results = results_fn(**function_kwargs)\n        for r in stream_obj.yield_results(results):\n            if r is None:\n                return\n            yield r\n\n        await asyncio.sleep(stream_obj.get_wait_time(first_key))\n</code></pre>"},{"location":"api/utils/#pylemmy.utils.stream_apply","title":"<code>stream_apply(results_fns, unique_key_fns, callback, *, filter_fn=lambda _: True, limit=None, max_wait_time=300, min_wait_time=1, **function_kwargs)</code>","text":"<p>Helper function to generate streams.</p> <p>Parameters:</p> <ul> <li> <code>results_fns</code>             (<code>Sequence[Callable[[KwArg(Any)], Iterable[T]]]</code>)         \u2013          <p>A list of functions to call repeatedly, each of them outputting a list of objects.</p> </li> <li> <code>unique_key_fns</code>             (<code>Sequence[Callable[[T], str]]</code>)         \u2013          <p>A list of functions (same length as <code>function</code>), where each of them takes an object and outputs a unique id. This is used to keep track of what results were already yielded.</p> </li> <li> <code>callback</code>             (<code>Callable[[T], Any]</code>)         \u2013          <p>A function that is applied to each of the objects.</p> </li> <li> <code>filter_fn</code>             (<code>Callable[[T], bool]</code>, default:                 <code>lambda _: True</code> )         \u2013          <p>Ignore objects which return <code>True</code> for this function.</p> </li> <li> <code>limit</code>             (<code>Optional[int]</code>, default:                 <code>None</code> )         \u2013          <p>Maximum number of objects to yield.</p> </li> <li> <code>max_wait_time</code>             (<code>int</code>, default:                 <code>300</code> )         \u2013          <p>If a function returns no new results, the time between calls to it increases. This sets the maximum time (in seconds) to wait before calling it again.</p> </li> <li> <code>min_wait_time</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Minimum time (in seconds) to wait before calling the function again.</p> </li> <li> <code>function_kwargs</code>             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Keyword parameters that are passed to the function.</p> </li> </ul> Source code in <code>pylemmy/utils.py</code> <pre><code>def stream_apply(\n    results_fns: Sequence[Callable[[KwArg(Any)], Iterable[T]]],\n    unique_key_fns: Sequence[Callable[[T], str]],\n    callback: Callable[[T], Any],\n    *,\n    filter_fn: Callable[[T], bool] = lambda _: True,\n    limit: Optional[int] = None,\n    max_wait_time: int = 300,\n    min_wait_time: int = 1,\n    **function_kwargs: Any,\n):\n\"\"\"Helper function to generate streams.\n\n    :param results_fns: A list of functions to call repeatedly, each of them\n    outputting a list of objects.\n    :param unique_key_fns: A list of functions (same length as `function`), where\n    each of them takes an object and outputs a unique id.\n    This is used to keep track of what results were already yielded.\n    :param callback: A function that is applied to each of the objects.\n    :param filter_fn: Ignore objects which return `True` for this function.\n    :param limit: Maximum number of objects to yield.\n    :param max_wait_time: If a function returns no new results, the time between calls\n    to it increases. This sets the maximum time (in seconds) to wait before calling it\n    again.\n    :param min_wait_time: Minimum time (in seconds) to wait before calling the function\n    again.\n    :param function_kwargs: Keyword parameters that are passed to the function.\n    \"\"\"\n    if len(results_fns) != len(unique_key_fns):\n        msg = (\n            f\"The lengths of `generator_fns` and `unique_key_fns` need to be the same. \"\n            f\"Got {len(results_fns)} and {len(unique_key_fns)}.\"\n        )\n        raise ValueError(msg)\n    asyncio.run(\n        _merge_streams(\n            results_fns,\n            unique_key_fns,\n            callback,\n            filter_fn=filter_fn,\n            limit=limit,\n            max_wait_time=max_wait_time,\n            min_wait_time=min_wait_time,\n            **function_kwargs,\n        )\n    )\n</code></pre>"},{"location":"api/utils/#pylemmy.utils.stream_generator","title":"<code>stream_generator(results_fn, unique_key_fn, *, filter_fn=lambda _: True, limit=None, max_wait_time=300, min_wait_time=1, skip_existing=False, **function_kwargs)</code>","text":"<p>Helper function to generate streams.</p> <p>Parameters:</p> <ul> <li> <code>results_fn</code>             (<code>Callable[[KwArg(Any)], Iterable[T]]</code>)         \u2013          <p>A function to call repeatedly, which outputs a list of objects.</p> </li> <li> <code>unique_key_fn</code>             (<code>Callable[[T], str]</code>)         \u2013          <p>A function that takes an object and outputs a unique id. This is used to keep track of what results were already yielded.</p> </li> <li> <code>filter_fn</code>             (<code>Callable[[T], bool]</code>, default:                 <code>lambda _: True</code> )         \u2013          <p>Ignore objects which return <code>True</code> for this function.</p> </li> <li> <code>limit</code>             (<code>Optional[int]</code>, default:                 <code>None</code> )         \u2013          <p>Maximum number of objects to yield.</p> </li> <li> <code>max_wait_time</code>             (<code>int</code>, default:                 <code>300</code> )         \u2013          <p>If a function returns no new results, the time between calls to it increases. This sets the maximum time (in seconds) to wait before calling it again.</p> </li> <li> <code>min_wait_time</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Minimum time (in seconds) to wait before calling the function again.</p> </li> <li> <code>skip_existing</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, skip existing results and return only future ones. In practice, this means the results from the first request are ignored.</p> </li> <li> <code>function_kwargs</code>             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Keyword parameters that are passed to the function.</p> </li> </ul> Source code in <code>pylemmy/utils.py</code> <pre><code>def stream_generator(\n    results_fn: Callable[[KwArg(Any)], Iterable[T]],\n    unique_key_fn: Callable[[T], str],\n    *,\n    filter_fn: Callable[[T], bool] = lambda _: True,\n    limit: Optional[int] = None,\n    max_wait_time: int = 300,\n    min_wait_time: int = 1,\n    skip_existing: bool = False,\n    **function_kwargs: Any,\n) -&gt; Generator[T, None, None]:\n\"\"\"Helper function to generate streams.\n\n    :param results_fn: A function to call repeatedly, which outputs a list of objects.\n    :param unique_key_fn: A function that takes an object and outputs a unique id.\n    This is used to keep track of what results were already yielded.\n    :param filter_fn: Ignore objects which return `True` for this function.\n    :param limit: Maximum number of objects to yield.\n    :param max_wait_time: If a function returns no new results, the time between calls\n    to it increases. This sets the maximum time (in seconds) to wait before calling it\n    again.\n    :param min_wait_time: Minimum time (in seconds) to wait before calling the function\n    again.\n    :param skip_existing: If `True`, skip existing results and return only future ones.\n    In practice, this means the results from the first request are ignored.\n    :param function_kwargs: Keyword parameters that are passed to the function.\n    \"\"\"\n    stream_obj = StreamYielder(\n        skip_existing=skip_existing,\n        filter_fn=filter_fn,\n        unique_key_fn=unique_key_fn,\n        limit=limit,\n        min_wait_time=min_wait_time,\n        max_wait_time=max_wait_time,\n    )\n    while True:\n        first_key = stream_obj.last_seen_key\n        results = results_fn(**function_kwargs)\n        for r in stream_obj.yield_results(results):\n            if r is None:\n                return\n            yield r\n\n        time.sleep(stream_obj.get_wait_time(first_key))\n</code></pre>"},{"location":"api/models/comment/","title":"Comment","text":"<p>Implements the Comment class.</p>"},{"location":"api/models/comment/#pylemmy.models.comment.Comment","title":"<code>Comment(lemmy, comment, community=None, post=None)</code>","text":"<p>A class for Comments.</p> <p>Initialize a Comment instance.</p> <p>Parameters:</p> <ul> <li> <code>lemmy</code>             (<code>Lemmy</code>)         \u2013          <p>A Lemmy instance.</p> </li> <li> <code>comment</code>             (<code>CommentView</code>)         \u2013          <p>A CommentView.</p> </li> <li> <code>community</code>             (<code>Optional[Community]</code>, default:                 <code>None</code> )         \u2013          <p>The Community in which this was posted.</p> </li> <li> <code>post</code>             (<code>Optional[Post]</code>, default:                 <code>None</code> )         \u2013          <p>The Post under which this comment was posted.</p> </li> </ul> Source code in <code>pylemmy/models/comment.py</code> <pre><code>def __init__(\n    self,\n    lemmy: \"pylemmy.Lemmy\",\n    comment: api.comment.CommentView,\n    community: Optional[\"pylemmy.models.community.Community\"] = None,\n    post: Optional[\"pylemmy.models.post.Post\"] = None,\n):\n\"\"\"Initialize a Comment instance.\n\n    :param lemmy: A Lemmy instance.\n    :param comment: A [CommentView](\n    https://join-lemmy.org/api/interfaces/CommentView.html).\n    :param community: The Community in which this was posted.\n    :param post: The Post under which this comment was posted.\n    \"\"\"\n    self.lemmy = lemmy\n    self.comment_view = comment\n\n    self._post = post\n    self._community = community\n</code></pre>"},{"location":"api/models/comment/#pylemmy.models.comment.Comment.community","title":"<code>community: pylemmy.models.community.Community</code>  <code>property</code>","text":"<p>The Community in which this was posted.</p>"},{"location":"api/models/comment/#pylemmy.models.comment.Comment.post","title":"<code>post: pylemmy.models.post.Post</code>  <code>property</code>","text":"<p>The Post under which this comment was posted.</p>"},{"location":"api/models/comment/#pylemmy.models.comment.Comment.create_report","title":"<code>create_report(reason)</code>","text":"<p>Report this comment.</p> <p>Parameters:</p> <ul> <li> <code>reason</code>             (<code>str</code>)         \u2013          <p>A reason for the report.</p> </li> </ul> Source code in <code>pylemmy/models/comment.py</code> <pre><code>def create_report(self, reason: str) -&gt; CommentReport:\n\"\"\"Report this comment.\n\n    :param reason: A reason for the report.\n    \"\"\"\n    self.lemmy.get_token()\n    payload = api.comment.CreateCommentReport(\n        comment_id=self.comment_view.comment.id,\n        reason=reason,\n    )\n    result = self.lemmy.post_request(LemmyAPI.CreateCommentReport, params=payload)\n\n    parsed_result = api.comment.CommentReportResponse(**result)\n    return CommentReport(\n        lemmy=self.lemmy, report=parsed_result.comment_report_view, comment=self\n    )\n</code></pre>"},{"location":"api/models/comment/#pylemmy.models.comment.CommentReport","title":"<code>CommentReport(lemmy, report, comment=None)</code>","text":"<p>A class for Comment reports.</p> <p>Initialize a Comment instance.</p> <p>Parameters:</p> <ul> <li> <code>lemmy</code>             (<code>Lemmy</code>)         \u2013          <p>A Lemmy instance.</p> </li> <li> <code>report</code>             (<code>CommentReportView</code>)         \u2013          <p>A CommentReportView.</p> </li> <li> <code>comment</code>             (<code>Optional[Comment]</code>, default:                 <code>None</code> )         \u2013          <p>The comment being reported.</p> </li> </ul> Source code in <code>pylemmy/models/comment.py</code> <pre><code>def __init__(\n    self,\n    lemmy: \"pylemmy.Lemmy\",\n    report: api.comment.CommentReportView,\n    comment: Optional[\"Comment\"] = None,\n):\n\"\"\"Initialize a Comment instance.\n\n    :param lemmy: A Lemmy instance.\n    :param report: A [CommentReportView](\n    https://join-lemmy.org/api/interfaces/CommentReportView.html).\n    :param comment: The comment being reported.\n    \"\"\"\n    self.lemmy = lemmy\n    self.report_view = report\n    self.comment = comment\n</code></pre>"},{"location":"api/models/comment/#pylemmy.models.comment.CommentReport.resolve","title":"<code>resolve(*, resolved)</code>","text":"<p>Resolve a comment report.</p> <p>Parameters:</p> <ul> <li> <code>resolved</code>             (<code>bool</code>)         \u2013          <p>Either resolve or unresolve the report.</p> </li> </ul> Source code in <code>pylemmy/models/comment.py</code> <pre><code>def resolve(self, *, resolved: bool) -&gt; \"CommentReport\":\n\"\"\"Resolve a comment report.\n\n    :param resolved: Either resolve or unresolve the report.\n    \"\"\"\n    self.lemmy.get_token()\n    payload = api.comment.ResolveCommentReport(\n        report_id=self.report_view.comment_report.id,\n        resolved=resolved,\n    )\n    result = self.lemmy.put_request(LemmyAPI.ResolveCommentReport, params=payload)\n    parsed_result = api.comment.CommentReportView(**result)\n\n    return CommentReport(\n        lemmy=self.lemmy, report=parsed_result, comment=self.comment\n    )\n</code></pre>"},{"location":"api/models/community/","title":"Community","text":"<p>Implements the Community class.</p>"},{"location":"api/models/community/#pylemmy.models.community.Community","title":"<code>Community(lemmy, community)</code>","text":"<p>A class for Communities.</p> <p>To obtain an instance of this class for c/test run:</p> <pre><code>community = lemmy.get_community(\"test\")\n</code></pre> <p>Initialize a Community instance.</p> <p>Parameters:</p> <ul> <li> <code>lemmy</code>             (<code>Lemmy</code>)         \u2013          <p>A Lemmy instance.</p> </li> <li> <code>community</code>             (<code>CommunityView</code>)         \u2013          <p>A CommunityView.</p> </li> </ul> Source code in <code>pylemmy/models/community.py</code> <pre><code>def __init__(self, lemmy: \"pylemmy.Lemmy\", community: api.community.CommunityView):\n\"\"\"Initialize a Community instance.\n\n    :param lemmy: A Lemmy instance.\n    :param community: A [CommunityView](\n    https://join-lemmy.org/api/interfaces/CommunityView.html).\n    \"\"\"\n    self.lemmy = lemmy\n    self.blocked = community.blocked\n    self.safe = community.community\n    self.counts = community.counts\n    self.subscribed = community.subscribed\n</code></pre>"},{"location":"api/models/community/#pylemmy.models.community.Community.stream","title":"<code>stream: CommunityStream</code>  <code>property</code>","text":"<p>Returns a stream of content.</p> <p>This stream is to be used to monitor posts or comments.</p> <p>Example:</p> <pre><code>community = lemmy.get_community(\"test\")\nfor post in community.stream.get_posts():\n    process_post(post)\n</code></pre>"},{"location":"api/models/community/#pylemmy.models.community.Community.create_post","title":"<code>create_post(name, **kwargs)</code>","text":"<p>Create a new post in this Community.</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Name of the post.</p> </li> <li> <code>kwargs</code>         \u2013          <p>See optional arguments in CreatePost.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Post</code>         \u2013          <p>The created Post.</p> </li> </ul> Source code in <code>pylemmy/models/community.py</code> <pre><code>def create_post(self, name: str, **kwargs) -&gt; Post:\n\"\"\"Create a new post in this Community.\n\n    :param name: Name of the post.\n    :param kwargs: See optional arguments in [CreatePost](\n    https://join-lemmy.org/api/interfaces/CreatePost.html).\n    :return: The created Post.\n    \"\"\"\n    self.lemmy.get_token()\n    payload = api.post.CreatePost(name=name, community_id=self.safe.id, **kwargs)\n    result = self.lemmy.post_request(LemmyAPI.Post, params=payload)\n    parsed_result = api.post.PostResponse(**result)\n\n    return Post(self.lemmy, parsed_result.post_view, community=self)\n</code></pre>"},{"location":"api/models/community/#pylemmy.models.community.Community.get_comments","title":"<code>get_comments(**kwargs)</code>","text":"<p>Gets a list of Comments from this community.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>         \u2013          <p>See optional arguments in GetComments.</p> </li> </ul> Source code in <code>pylemmy/models/community.py</code> <pre><code>def get_comments(self, **kwargs) -&gt; List[Comment]:\n\"\"\"Gets a list of Comments from this community.\n\n    :param kwargs: See optional arguments in [GetComments](\n    https://join-lemmy.org/api/interfaces/GetComments.html).\n    \"\"\"\n    payload = api.comment.GetComments(community_id=self.safe.id, **kwargs)\n    result = self.lemmy.get_request(LemmyAPI.GetComments, params=payload)\n    parsed_result = api.comment.GetCommentsResponse(**result)\n\n    return [Comment(self.lemmy, comment) for comment in parsed_result.comments]\n</code></pre>"},{"location":"api/models/community/#pylemmy.models.community.Community.get_posts","title":"<code>get_posts(**kwargs)</code>","text":"<p>Gets a list of Posts from this community.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>         \u2013          <p>See optional arguments in GetPosts.</p> </li> </ul> Source code in <code>pylemmy/models/community.py</code> <pre><code>def get_posts(self, **kwargs) -&gt; List[Post]:\n\"\"\"Gets a list of Posts from this community.\n\n    :param kwargs: See optional arguments in [GetPosts](\n    https://join-lemmy.org/api/interfaces/GetPosts.html).\n    \"\"\"\n    payload = api.post.GetPosts(community_id=self.safe.id, **kwargs)\n    result = self.lemmy.get_request(LemmyAPI.GetPosts, params=payload)\n    parsed_result = api.post.GetPostsResponse(**result)\n\n    return [Post(self.lemmy, post, community=self) for post in parsed_result.posts]\n</code></pre>"},{"location":"api/models/community/#pylemmy.models.community.Community.list_comment_reports","title":"<code>list_comment_reports(**kwargs)</code>","text":"<p>List comment reports in this community.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>         \u2013          <p>See optional arguments in ListCommentReports.</p> </li> </ul> Source code in <code>pylemmy/models/community.py</code> <pre><code>def list_comment_reports(self, **kwargs) -&gt; List[api.comment.CommentReportView]:\n\"\"\"List comment reports in this community.\n\n    :param kwargs: See optional arguments in [ListCommentReports](\n    https://join-lemmy.org/api/interfaces/ListCommentReports.html).\n    \"\"\"\n    return self.lemmy.list_comment_reports(community_id=self.safe.id, **kwargs)\n</code></pre>"},{"location":"api/models/community/#pylemmy.models.community.Community.list_post_reports","title":"<code>list_post_reports(**kwargs)</code>","text":"<p>List post reports in this community.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>         \u2013          <p>See optional arguments in ListPostReports.</p> </li> </ul> Source code in <code>pylemmy/models/community.py</code> <pre><code>def list_post_reports(self, **kwargs) -&gt; List[api.post.PostReportView]:\n\"\"\"List post reports in this community.\n\n    :param kwargs: See optional arguments in [ListPostReports](\n    https://join-lemmy.org/api/interfaces/ListPostReports.html).\n    \"\"\"\n    return self.lemmy.list_post_reports(community_id=self.safe.id, **kwargs)\n</code></pre>"},{"location":"api/models/community/#pylemmy.models.community.CommunityStream","title":"<code>CommunityStream(community)</code>","text":"<p>Helper class to stream content from a specific community.</p> <p>This class shouldn't be directly initialized, but rather accessed through Community.</p> <p>Example:</p> <pre><code>community = lemmy.get_community(\"test\")\nfor post in community.stream.get_posts():\n    process_post(post)\n</code></pre> <p>Initialize a CommunityStream.</p> <p>Parameters:</p> <ul> <li> <code>community</code>             (<code>Community</code>)         \u2013          <p>A Community to run the stream on.</p> </li> </ul> Source code in <code>pylemmy/models/community.py</code> <pre><code>def __init__(self, community: Community):\n\"\"\"Initialize a CommunityStream.\n\n    :param community: A Community to run the stream on.\n    \"\"\"\n    self.community = community\n</code></pre>"},{"location":"api/models/community/#pylemmy.models.community.CommunityStream.get_comments","title":"<code>get_comments(**kwargs)</code>","text":"<p>Get a stream of Comments in the Community.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>         \u2013          <p>See the optional arguments in stream_generator.</p> </li> </ul> Source code in <code>pylemmy/models/community.py</code> <pre><code>def get_comments(self, **kwargs):\n\"\"\"Get a stream of Comments in the Community.\n\n    :param kwargs: See the optional arguments in\n    [stream_generator][pylemmy.utils.stream_generator].\n    \"\"\"\n    return stream_generator(\n        self.community.get_comments,\n        lambda x: str(x.comment_view.comment.ap_id),\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/models/community/#pylemmy.models.community.CommunityStream.get_posts","title":"<code>get_posts(**kwargs)</code>","text":"<p>Get a stream of Posts in the Community.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>         \u2013          <p>See the optional arguments in stream_generator.</p> </li> </ul> Source code in <code>pylemmy/models/community.py</code> <pre><code>def get_posts(self, **kwargs):\n\"\"\"Get a stream of Posts in the Community.\n\n    :param kwargs: See the optional arguments in\n    [stream_generator][pylemmy.utils.stream_generator].\n    \"\"\"\n    return stream_generator(\n        self.community.get_posts,\n        lambda x: str(x.post_view.post.ap_id),\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/models/community/#pylemmy.models.community.MultiCommunityStream","title":"<code>MultiCommunityStream(communities)</code>","text":"<p>Helper class to stream content from multiple communities.</p> <p>This class shouldn't be directly initialized, but rather accessed through Lemmy.</p> <p>Example: A simple example where we want to print the content of each post.</p> <pre><code>def process_content(elem: Union[Post, Comment]):\n        print(elem.post_view.post.name)\n\nmulti_stream = lemmy.multi_communities_stream([\"community1\", \"community2\"])\nmulti_stream.content_apply(process_content)\n</code></pre> <p>Initializer for MultiCommunityStream.</p> <p>Parameters:</p> <ul> <li> <code>communities</code>             (<code>List[Community]</code>)         \u2013          <p>A list of communities to monitor.</p> </li> </ul> Source code in <code>pylemmy/models/community.py</code> <pre><code>def __init__(self, communities: List[Community]):\n\"\"\"Initializer for MultiCommunityStream.\n\n    :param communities: A list of communities to monitor.\n    \"\"\"\n    self.communities = communities\n</code></pre>"},{"location":"api/models/community/#pylemmy.models.community.MultiCommunityStream.comments_apply","title":"<code>comments_apply(callback, **kwargs)</code>","text":"<p>Apply a callback function to a stream of Comments in the Communities.</p> <p>Example: A simple example where we want to print the content of each comment.</p> <pre><code>def process_content(elem: Union[Post, Comment]):\n    print(elem.comment_view.comment.content)\n\nmulti_stream = lemmy.multi_communities_stream([\"community1\", \"community2\"])\nmulti_stream.content_apply(process_content)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>callback</code>             (<code>Callable[[Comment], Any]</code>)         \u2013          <p>Function that will be called for each Comment.</p> </li> <li> <code>kwargs</code>         \u2013          <p>See the optional arguments in stream_generator.</p> </li> </ul> Source code in <code>pylemmy/models/community.py</code> <pre><code>def comments_apply(self, callback: Callable[[Comment], Any], **kwargs):\n\"\"\"Apply a callback function to a stream of Comments in the Communities.\n\n    Example:\n    A simple example where we want to print the content of each comment.\n\n        def process_content(elem: Union[Post, Comment]):\n            print(elem.comment_view.comment.content)\n\n        multi_stream = lemmy.multi_communities_stream([\"community1\", \"community2\"])\n        multi_stream.content_apply(process_content)\n\n    :param callback: Function that will be called for each Comment.\n    :param kwargs: See the optional arguments in\n    [stream_generator][pylemmy.utils.stream_generator].\n    \"\"\"\n    results_fns = [c.get_comments for c in self.communities]\n    unique_keys_fns = [lambda x: str(x.comment_view.comment.ap_id)] * len(\n        self.communities\n    )\n    stream_apply(results_fns, unique_keys_fns, callback, **kwargs)\n</code></pre>"},{"location":"api/models/community/#pylemmy.models.community.MultiCommunityStream.content_apply","title":"<code>content_apply(callback, **kwargs)</code>","text":"<p>Apply a callback function to a stream of Comments and Posts.</p> <p>Example: A simple example where we want to print the content of each post/comment.</p> <pre><code>def process_content(elem: Union[Post, Comment]):\n    if isinstance(Post, elem):\n        print(elem.post_view.post.name)\n    elif isinstance(Comment, elem):\n        print(elem.comment_view.comment.content)\n\nmulti_stream = lemmy.multi_communities_stream([\"community1\", \"community2\"])\nmulti_stream.content_apply(process_content)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>callback</code>             (<code>Callable[[Union[Comment, Post]], Any]</code>)         \u2013          <p>Function that will be called for each Comment/Post.</p> </li> <li> <code>kwargs</code>         \u2013          <p>See the optional arguments in stream_generator.</p> </li> </ul> Source code in <code>pylemmy/models/community.py</code> <pre><code>def content_apply(self, callback: Callable[[Union[Comment, Post]], Any], **kwargs):\n\"\"\"Apply a callback function to a stream of Comments and Posts.\n\n    Example:\n    A simple example where we want to print the content of each post/comment.\n\n        def process_content(elem: Union[Post, Comment]):\n            if isinstance(Post, elem):\n                print(elem.post_view.post.name)\n            elif isinstance(Comment, elem):\n                print(elem.comment_view.comment.content)\n\n        multi_stream = lemmy.multi_communities_stream([\"community1\", \"community2\"])\n        multi_stream.content_apply(process_content)\n\n\n    :param callback: Function that will be called for each Comment/Post.\n    :param kwargs: See the optional arguments in\n    [stream_generator][pylemmy.utils.stream_generator].\n    \"\"\"\n    posts_fns: List[Callable[[KwArg(Any)], Iterable[Union[Post, Comment]]]] = [\n        c.get_posts for c in self.communities\n    ]\n    comments_fns: List[Callable[[KwArg(Any)], Iterable[Union[Post, Comment]]]] = [\n        c.get_comments for c in self.communities\n    ]\n\n    posts_unique_keys_fns = [lambda x: \"post_\" + str(x.post_view.post.ap_id)] * len(\n        self.communities\n    )\n    comments_unique_keys_fns = [\n        lambda x: \"comment_\" + str(x.comment_view.comment.ap_id)\n    ] * len(self.communities)\n    stream_apply(\n        posts_fns + comments_fns,\n        posts_unique_keys_fns + comments_unique_keys_fns,\n        callback,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/models/community/#pylemmy.models.community.MultiCommunityStream.posts_apply","title":"<code>posts_apply(callback, **kwargs)</code>","text":"<p>Apply a callback function to a stream of Posts in the Communities.</p> <p>Example: A simple example where we want to print the content of each post.</p> <pre><code>def process_content(elem: Union[Post, Comment]):\n    print(elem.post_view.post.name)\n\nmulti_stream = lemmy.multi_communities_stream([\"community1\", \"community2\"])\nmulti_stream.content_apply(process_content)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>callback</code>             (<code>Callable[[Post], Any]</code>)         \u2013          <p>Function that will be called for each Post.</p> </li> <li> <code>kwargs</code>         \u2013          <p>See the optional arguments in stream_generator.</p> </li> </ul> Source code in <code>pylemmy/models/community.py</code> <pre><code>def posts_apply(self, callback: Callable[[Post], Any], **kwargs):\n\"\"\"Apply a callback function to a stream of Posts in the Communities.\n\n    Example:\n    A simple example where we want to print the content of each post.\n\n        def process_content(elem: Union[Post, Comment]):\n            print(elem.post_view.post.name)\n\n        multi_stream = lemmy.multi_communities_stream([\"community1\", \"community2\"])\n        multi_stream.content_apply(process_content)\n\n    :param callback: Function that will be called for each Post.\n    :param kwargs: See the optional arguments in\n    [stream_generator][pylemmy.utils.stream_generator].\n    \"\"\"\n    results_fns = [c.get_posts for c in self.communities]\n    unique_keys_fns = [lambda x: str(x.post_view.post.ap_id)] * len(\n        self.communities\n    )\n    stream_apply(results_fns, unique_keys_fns, callback, **kwargs)\n</code></pre>"},{"location":"api/models/post/","title":"Post","text":"<p>Implements the Post class.</p>"},{"location":"api/models/post/#pylemmy.models.post.Post","title":"<code>Post(lemmy, post, community=None)</code>","text":"<p>A class for Posts.</p> <p>Initialize a Post instance.</p> <p>Parameters:</p> <ul> <li> <code>lemmy</code>             (<code>Lemmy</code>)         \u2013          <p>A Lemmy instance.</p> </li> <li> <code>post</code>             (<code>PostView</code>)         \u2013          <p>A PostView.</p> </li> <li> <code>community</code>             (<code>Optional[Community]</code>, default:                 <code>None</code> )         \u2013          <p>The Community in which this was posted.</p> </li> </ul> Source code in <code>pylemmy/models/post.py</code> <pre><code>def __init__(\n    self,\n    lemmy: \"pylemmy.Lemmy\",\n    post: api.post.PostView,\n    community: Optional[\"pylemmy.models.community.Community\"] = None,\n):\n\"\"\"Initialize a Post instance.\n\n    :param lemmy: A Lemmy instance.\n    :param post: A [PostView](\n    https://join-lemmy.org/api/interfaces/PostView.html).\n    :param community: The Community in which this was posted.\n    \"\"\"\n    self.lemmy = lemmy\n    self.post_view = post\n\n    self._community = community\n</code></pre>"},{"location":"api/models/post/#pylemmy.models.post.Post.community","title":"<code>community: pylemmy.models.community.Community</code>  <code>property</code>","text":"<p>The Community in which this Post was posted.</p>"},{"location":"api/models/post/#pylemmy.models.post.Post.create_comment","title":"<code>create_comment(content, **kwargs)</code>","text":"<p>Create a new Comment under this Post.</p> <p>Parameters:</p> <ul> <li> <code>content</code>             (<code>str</code>)         \u2013          <p>Content of the comment.</p> </li> <li> <code>kwargs</code>         \u2013          <p>See optional arguments in CreateComment.</p> </li> </ul> Source code in <code>pylemmy/models/post.py</code> <pre><code>def create_comment(self, content: str, **kwargs) -&gt; Comment:\n\"\"\"Create a new Comment under this Post.\n\n    :param content: Content of the comment.\n    :param kwargs: See optional arguments in [CreateComment](\n    https://join-lemmy.org/api/interfaces/CreateComment.html).\n    \"\"\"\n    self.lemmy.get_token()\n    payload = api.comment.CreateComment(\n        content=content,\n        post_id=self.post_view.post.id,\n        **kwargs,\n    )\n    result = self.lemmy.post_request(LemmyAPI.Comment, params=payload)\n    parsed_result = api.comment.CommentResponse(**result)\n\n    return Comment(\n        self.lemmy, parsed_result.comment_view, post=self, community=self._community\n    )\n</code></pre>"},{"location":"api/models/post/#pylemmy.models.post.Post.create_report","title":"<code>create_report(reason)</code>","text":"<p>Report this post.</p> <p>Parameters:</p> <ul> <li> <code>reason</code>             (<code>str</code>)         \u2013          <p>A reason for the report.</p> </li> </ul> Source code in <code>pylemmy/models/post.py</code> <pre><code>def create_report(self, reason: str) -&gt; PostReport:\n\"\"\"Report this post.\n\n    :param reason: A reason for the report.\n    \"\"\"\n    self.lemmy.get_token()\n    payload = api.post.CreatePostReport(\n        post_id=self.post_view.post.id, reason=reason\n    )\n    result = self.lemmy.post_request(LemmyAPI.CreatePostReport, params=payload)\n\n    parsed_result = api.post.PostReportResponse(**result)\n    return PostReport(\n        lemmy=self.lemmy, report=parsed_result.post_report_view, post=self\n    )\n</code></pre>"},{"location":"api/models/post/#pylemmy.models.post.Post.get_comments","title":"<code>get_comments(**kwargs)</code>","text":"<p>Get Comments under this Post.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>         \u2013          <p>See optional arguments in GetComments.</p> </li> </ul> Source code in <code>pylemmy/models/post.py</code> <pre><code>def get_comments(self, **kwargs) -&gt; List[Comment]:\n\"\"\"Get Comments under this Post.\n\n    :param kwargs: See optional arguments in [GetComments](\n    https://join-lemmy.org/api/interfaces/GetComments.html).\n    \"\"\"\n    payload = api.comment.GetComments(\n        post_id=self.post_view.post.id,\n        **kwargs,\n    )\n    result = self.lemmy.get_request(LemmyAPI.GetComments, params=payload)\n    parsed_result = api.comment.GetCommentsResponse(**result)\n\n    return [\n        Comment(self.lemmy, comment, post=self, community=self._community)\n        for comment in parsed_result.comments\n    ]\n</code></pre>"},{"location":"api/models/post/#pylemmy.models.post.PostReport","title":"<code>PostReport(lemmy, report, post=None)</code>","text":"<p>A class for Post reports.</p> <p>Initialize a Post instance.</p> <p>Parameters:</p> <ul> <li> <code>lemmy</code>             (<code>Lemmy</code>)         \u2013          <p>A Lemmy instance.</p> </li> <li> <code>report</code>             (<code>PostReportView</code>)         \u2013          <p>A PostReportView.</p> </li> <li> <code>post</code>             (<code>Optional[Post]</code>, default:                 <code>None</code> )         \u2013          <p>The post being reported.</p> </li> </ul> Source code in <code>pylemmy/models/post.py</code> <pre><code>def __init__(\n    self,\n    lemmy: \"pylemmy.Lemmy\",\n    report: api.post.PostReportView,\n    post: Optional[\"Post\"] = None,\n):\n\"\"\"Initialize a Post instance.\n\n    :param lemmy: A Lemmy instance.\n    :param report: A [PostReportView](\n    https://join-lemmy.org/api/interfaces/PostReportView.html).\n    :param post: The post being reported.\n    \"\"\"\n    self.lemmy = lemmy\n    self.report_view = report\n    self.post = post\n</code></pre>"},{"location":"api/models/post/#pylemmy.models.post.PostReport.resolve","title":"<code>resolve(*, resolved)</code>","text":"<p>Resolve a post report.</p> <p>Parameters:</p> <ul> <li> <code>resolved</code>             (<code>bool</code>)         \u2013          <p>Either resolve or unresolve the report.</p> </li> </ul> Source code in <code>pylemmy/models/post.py</code> <pre><code>def resolve(self, *, resolved: bool) -&gt; \"PostReport\":\n\"\"\"Resolve a post report.\n\n    :param resolved: Either resolve or unresolve the report.\n    \"\"\"\n    self.lemmy.get_token()\n    payload = api.post.ResolvePostReport(\n        report_id=self.report_view.post_report.id,\n        resolved=resolved,\n    )\n    result = self.lemmy.put_request(LemmyAPI.ResolvePostReport, params=payload)\n    parsed_result = api.post.PostReportView(**result)\n\n    return PostReport(lemmy=self.lemmy, report=parsed_result, post=self.post)\n</code></pre>"}]}